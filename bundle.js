(()=>{"use strict";var e={556:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const r=n(522);t.default=class{constructor(e){this.enclosing=e,this.idMap=new Map}define(e,t){this.idMap.set(e,t)}get(e){const t=this.idMap.get(e);return void 0!==t?t:null!==this.enclosing?this.enclosing.get(e):void 0}assign(e,t){if(this.idMap.has(e))this.idMap.set(e,t);else{if(null===this.enclosing)throw Error("Undefined variable.");this.enclosing.assign(e,t)}}getAt(e,t){const n=this.ancestor(e).idMap.get(t);if(void 0===n)throw new r.ImplementationError(`Incorrect distance given for ${t}.`);return n}assignAt(e,t,n){this.ancestor(e).idMap.set(t,n)}ancestor(e){let t=this;for(let n=0;n<e;n++){if(null===t.enclosing)throw new r.ImplementationError("Given distance to interpreter ancestor function is too high.");t=t.enclosing}return t}}},522:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ImplementationError=t.SyntaxTreeNodeError=t.TokenRangeError=t.TokenError=t.CharacterError=t.LangError=void 0;class n extends Error{constructor(e){super(),this.message=e}}t.LangError=n,t.CharacterError=class extends n{constructor(e,t,n,r){super(e),this.lineString=t,this.lineIndex=n,this.column=r}toString(){const e=" ".repeat(this.column-1);return`[line ${this.lineIndex}, column ${this.column}] ${this.message}\n`+this.lineString+"\n"+e+"^"}},t.TokenError=class extends n{constructor(e,t){super(e),this.token=t}toString(){if("EOF"===this.token.type)return`(at the end of the file) ${this.message}`;{const e=i(this.token.column,this.token.column+this.token.lexeme.length-1);return`[line ${this.token.lineIndex}, column ${this.token.column}] ${this.message}\n`+this.token.lineString+"\n"+e}}};class r extends n{constructor(e,t,n){super(e),this.tokenStart=t,this.tokenEnd=n}toString(){const e=this.tokenStart,t=this.tokenEnd,n=this.tokenStart.lineString,r=this.tokenStart.lineIndex,a=this.tokenEnd.lineString,o=t.lineIndex,c=e.column,l=t.column;if(o<r||"EOF"===e.type||"EOF"===t.type)throw new s("Bad ranges for TokenRangeError.");if(r===o){if(l<c)throw new s("Ending column comes before starting column.");const e=i(c,l);let t=`[line ${r}, column ${c} to column ${l}] `;return t+=`${this.message}\n${n}\n${e}`,t}if(o-r==1){const e=i(c,c+n.length-1),t=i(1,l);let s=`[line ${r}, column ${c} to line ${o}, column ${l}] `;return s+=`${this.message}\n`,s+=`${n}\n${e}\n`,s+=`${a}\n${t}`,s}const h=i(c,c+n.length-1),p=i(1,l);let u=`[line ${r}, column ${c} to line ${o}, column ${l}] `;return u+=`${this.message}\n`,u+=`${n}\n${h}`,u+="\n\n... (inner lines omitted) ...\n\n",u+=`${a}\n${p}`,u}}t.TokenRangeError=r,t.SyntaxTreeNodeError=class extends r{constructor(e,t){super(e,t.lToken,t.rToken)}toString(){return super.toString()}};class s extends Error{constructor(e){super("Implementation error: "+e)}}function i(e,t){if(t<e)throw new s("Invalid indices given for offset.");return" ".repeat(e-1)+"^".repeat(t-e+1)}t.ImplementationError=s},101:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.VariableExpr=t.UnaryExpr=t.LiteralExpr=t.LogicalExpr=t.GroupingExpr=t.FunctionObjectExpr=t.CallExpr=t.BinaryExpr=t.AssignExpr=t.ArrayObjectExpr=t.ArrayAssignExpr=t.ArrayAccessExpr=t.Expr=void 0;const s=r(n(871));class i extends s.default{}t.Expr=i,t.ArrayAccessExpr=class extends i{constructor(e,t,n){super(e.lToken,n),this.arrayExpr=e,this.index=t}accept(e){return e.visitArrayAccessExpr(this)}},t.ArrayAssignExpr=class extends i{constructor(e,t){super(e.lToken,t.rToken),this.arrayAccessExpr=e,this.assignmentValue=t}accept(e){return e.visitArrayAssignExpr(this)}},t.ArrayObjectExpr=class extends i{constructor(e,t,n,r){super(n,r),this.capacity=e,this.elements=t}accept(e){return e.visitArrayObjectExpr(this)}},t.AssignExpr=class extends i{constructor(e,t){super(e,t.rToken),this.value=t}accept(e){return e.visitAssignExpr(this)}},t.BinaryExpr=class extends i{constructor(e,t,n){super(e.lToken,n.rToken),this.leftExpr=e,this.operator=t,this.rightExpr=n}accept(e){return e.visitBinaryExpr(this)}},t.CallExpr=class extends i{constructor(e,t,n){super(e.lToken,t),this.callee=e,this.args=n}accept(e){return e.visitCallExpr(this)}},t.FunctionObjectExpr=class extends i{constructor(e,t,n,r,s){super(s,r.rToken),this.parameterTokens=e,this.parameterTypes=t,this.returnType=n,this.statement=r}accept(e){return e.visitFunctionObjectExpr(this)}},t.GroupingExpr=class extends i{constructor(e,t,n){super(e,n),this.expression=t}accept(e){return e.visitGroupingExpr(this)}},t.LogicalExpr=class extends i{constructor(e,t,n){super(e.lToken,n.rToken),this.leftExpr=e,this.operator=t,this.rightExpr=n}accept(e){return e.visitLogicalExpr(this)}},t.LiteralExpr=class extends i{constructor(e,t){super(t,t),this.value=e}accept(e){return e.visitLiteralExpr(this)}},t.UnaryExpr=class extends i{constructor(e,t){super(e,t.rToken),this.operator=e,this.rightExpr=t}accept(e){return e.visitUnaryExpr(this)}},t.VariableExpr=class extends i{constructor(e){super(e,e)}accept(e){return e.visitVariableExpr(this)}}},58:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ReturnIndicator=t.BreakIndicator=void 0,t.BreakIndicator=class{},t.ReturnIndicator=class{constructor(e){this.value=e}}},219:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=n(101),i=n(522),a=n(680),o=r(n(556)),c=n(58);t.default=class{constructor(e){this.program=e,this.printedLines=[],this.globalEnvironment=new o.default(null),this.currentEnvironment=this.globalEnvironment,this.functionEnvironment=null,this.localVariableDistances=new Map}interpret(){for(const e of this.program)this.execute(e);return this.printedLines.join("\n")}evaluate(e){return e.accept(this)}execute(e){if(null!==this.functionEnvironment){const t=this.currentEnvironment;this.currentEnvironment=this.functionEnvironment,this.functionEnvironment=null;try{e.accept(this)}finally{this.currentEnvironment=t}}else e.accept(this)}visitBlankStmt(e){}visitPrintStmt(e){const t=this.evaluate(e.expression);this.printedLines.push(this.stringify(t))}visitExpressionStmt(e){this.evaluate(e.expression)}visitDeclarationStmt(e){const t=this.evaluate(e.initialValue),n=e.identifier.lexeme;try{this.currentEnvironment.define(n,t)}catch(t){if(t instanceof Error)throw new i.SyntaxTreeNodeError(t.message,e);throw new i.ImplementationError("Unable to define variable.")}}visitBlockStmt(e){const t=this.currentEnvironment;let n;null!==this.functionEnvironment?(n=new o.default(this.functionEnvironment),this.functionEnvironment=null):n=new o.default(t),this.currentEnvironment=n;try{for(const t of e.statements)this.execute(t)}finally{this.currentEnvironment=t}}visitIfStmt(e){this.evaluate(e.condition)?this.execute(e.thenBranch):null!==e.elseBranch&&this.execute(e.elseBranch)}visitWhileStmt(e){for(;this.evaluate(e.condition);)try{this.execute(e.body)}catch(e){if(e instanceof c.BreakIndicator)break;throw e}}visitBreakStmt(e){throw new c.BreakIndicator}visitReturnStmt(e){const t=this.evaluate(e.value);throw new c.ReturnIndicator(t)}visitBinaryExpr(e){let t,n;switch(e.operator.type){case"EQUAL_EQUAL":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t===n;case"BANG_EQUAL":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t!=n;case"LESS":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t<n;case"LESS_EQUAL":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t<=n;case"GREATER":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t>n;case"GREATER_EQUAL":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t>=n;case"PLUS":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),"number"==typeof t&&"number"==typeof n?t+n:t.toString()+n.toString();case"MINUS":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t-n;case"STAR":return t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),t*n;case"SLASH":if(t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),0===n)throw new i.SyntaxTreeNodeError("Cannot divide by 0.",e);return t/n;case"PERCENT":if(t=this.evaluate(e.leftExpr),n=this.evaluate(e.rightExpr),0===n)throw new i.SyntaxTreeNodeError("Right side of mod cannot be 0.",e);return t%n}throw new i.ImplementationError("Unknown operator in binary expression.")}visitUnaryExpr(e){let t;switch(e.operator.type){case"MINUS":return t=this.evaluate(e.rightExpr),-t;case"BANG":return t=this.evaluate(e.rightExpr),t}throw new i.ImplementationError("Unknown operator in unary expression.")}visitGroupingExpr(e){return this.evaluate(e.expression)}visitLiteralExpr(e){return e.value}visitVariableExpr(e){return this.lookupVariable(e.lToken.lexeme,e)}visitAssignExpr(e){const t=e.lToken.lexeme,n=this.evaluate(e.value),r=this.localVariableDistances.get(e);return void 0!==r?this.currentEnvironment.assignAt(r,t,n):this.globalEnvironment.assign(t,n),n}visitLogicalExpr(e){const t=this.evaluate(e.leftExpr);if("OR"===e.operator.type){if(t)return!0}else if(!t)return!1;return this.evaluate(e.rightExpr)}visitFunctionObjectExpr(e){return new a.FunctionLangObject(e.parameterTokens,e.statement,this.currentEnvironment)}visitCallExpr(e){const t=this.evaluate(e.callee);let n=[];for(const t of e.args)n.push(this.evaluate(t));return t.call(this,n)}visitArrayObjectExpr(e){let t;if(e.capacity instanceof s.Expr){if(t=this.evaluate(e.capacity),t<0)throw new i.SyntaxTreeNodeError("Number must be positive.",e.capacity)}else t=e.capacity;let n=[];if(Array.isArray(e.elements)){n=[];for(const t of e.elements){const e=this.evaluate(t);n.push(e)}}else{const r=this.evaluate(e.elements);for(let e=0;e<t;e++)n.push(r)}return new a.ArrayLangObject(t,n)}visitArrayAccessExpr(e){const t=this.evaluate(e.index),n=this.evaluate(e.arrayExpr);if(t<0||t>n.capacity-1)throw new i.SyntaxTreeNodeError("Index is out of range.",e.index);return n.elements[t]}visitArrayAssignExpr(e){const t=e.arrayAccessExpr.arrayExpr,n=this.evaluate(e.arrayAccessExpr.index),r=this.evaluate(t);if(n<0||n>r.capacity-1)throw new i.SyntaxTreeNodeError("Index is out of range.",e.arrayAccessExpr.index);const s=this.evaluate(e.assignmentValue);return r.elements[n]=s,s}stringify(e){return null===e?"void function return":"number"==typeof e?e.toString():"boolean"==typeof e?e?"true":"false":e instanceof a.FunctionLangObject||e instanceof a.ArrayLangObject?e.toString():e}lookupVariable(e,t){const n=this.localVariableDistances.get(t);if(void 0!==n)return this.currentEnvironment.getAt(n,e);{const t=this.globalEnvironment.get(e);if(void 0===t)throw new i.ImplementationError(`Couldn't find distance for ${e}.`);return t}}resolve(e,t){this.localVariableDistances.set(e,t)}}},680:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.ArrayLangObject=t.FunctionLangObject=void 0;const s=r(n(556)),i=n(522),a=n(46),o=n(58);t.FunctionLangObject=class{constructor(e,t,n){this.parameterTokens=e,this.statement=t,this.closure=n}toString(){return"anonymous function object"}call(e,t){if(null==this.closure)throw new i.ImplementationError("Function called with no closure set.");const n=new s.default(this.closure);for(const e in this.parameterTokens){const r=this.parameterTokens[e].lexeme;n.define(r,t[e])}e.functionEnvironment=n;try{this.statement instanceof a.BlockStmt?e.visitBlockStmt(this.statement):e.execute(this.statement)}catch(e){if(e instanceof o.ReturnIndicator)return e.value;throw e}throw new i.ImplementationError("No return value was thrown by a function.")}},t.ArrayLangObject=class{constructor(e,t){this.capacity=e,this.elements=t}toString(){return"["+this.elements.toString()+"]"}}},746:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ArrayLangType=t.FunctionLangType=t.LangTypeEqual=t.ComplexLangType=void 0;class n{}function r(e,t){return e instanceof i&&t instanceof i||e instanceof s&&t instanceof s?e.equals(t):e===t}t.ComplexLangType=n,t.LangTypeEqual=r;class s extends n{constructor(e,t){super(),this.parameters=e,this.returnType=t}toString(){return"FunctionLangType"}equals(e){if(!(e instanceof s))return!1;if(!r(e.returnType,this.returnType))return!1;if(this.parameters.length!=e.parameters.length)return!1;for(const t in this.parameters)if(!r(this.parameters[t],e.parameters[t]))return!1;return!0}}t.FunctionLangType=s;class i extends n{constructor(e){super(),this.innerType=e}equals(e){return e instanceof i&&r(this.innerType,e.innerType)}}t.ArrayLangType=i},824:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const r=n(101),s=n(522),i=n(46),a=n(667),o="Expect a ';' before this token.";t.default=class{constructor(e){this.tokens=e,this.currentIndex=0}parse(){const e=[],t=[];for(;!this.isAtEnd();)try{e.push(this.parseStatement())}catch(e){if(!(e instanceof s.LangError))throw e;{t.push(e);let n=!1;for(;!this.isAtEnd()&&!n;){switch(this.peek().type){case"SEMICOLON":this.consume(),n=!0;break;case"FUNCTION":case"LET":case"FOR":case"IF":case"WHILE":case"PRINT":case"RETURN":case"BREAK":n=!0}n||this.consume()}}}if(t.length>0)throw t;return e}parseStatement(){let e;switch(this.peek().type){case"SEMICOLON":const t=this.consume();return new i.BlankStmt(t);case"BREAK":const n=this.consume(),r=this.expect("SEMICOLON",o);return new i.BreakStmt(n,r);case"IF":return this.parseIfStatement();case"LEFT_BRACE":return this.parseBlockStatement();case"WHILE":return this.parseWhileStatement();case"LET":return this.parseDeclarationStatement();case"PRINT":return this.parsePrintStatement();case"RETURN":return this.parseReturnStatement();default:e=this.parseExpressionStatement()}return e}parseIfStatement(){const e=this.expect("IF","Expect 'if' to start if statement."),t=this.parseExpression();this.expect("THEN","Expect 'then' after condition.");const n=this.parseStatement();let r=null;return this.match("ELSE")&&(this.consume(),r=this.parseStatement()),new i.IfStmt(e,t,n,r)}parseBlockStatement(){const e=this.expect("LEFT_BRACE","Expect '{' to begin block statement."),t=[];for(;!this.match("RIGHT_BRACE","EOF");)t.push(this.parseStatement());const n=this.expect("RIGHT_BRACE","Expect '}' to end block statement.");return new i.BlockStmt(e,t,n)}parseWhileStatement(){const e=this.expect("WHILE","Expect 'while' to begin while statement."),t=this.parseExpression();this.expect("DO","Expect 'do' after condition.");const n=this.parseStatement();return new i.WhileStmt(e,t,n)}parseExpressionStatement(){const e=this.parseExpression(),t=this.expect("SEMICOLON",o);return new i.ExpressionStmt(e,t)}parsePrintStatement(){const e=this.expect("PRINT","Expect initial 'print' for print statement."),t=this.parseExpression(),n=this.expect("SEMICOLON",o);return new i.PrintStmt(e,t,n)}parseDeclarationStatement(){const e=this.expect("LET","Expect 'let' before variable declaration."),t=this.expect("IDENTIFIER","Expect identifier name in declaration.");let n=null;this.match("COLON")&&(this.consume(),n=this.parseObjectType()),this.expect("EQUAL","Expect an '=' in a declaration.");const r=this.parseExpression(),s=this.expect("SEMICOLON",o);return new i.DeclarationStmt(e,t,n,r,s)}parseReturnStatement(){const e=this.expect("RETURN","Expect initial 'return' for return statement."),t=this.parseExpression(),n=this.expect("SEMICOLON",o);return new i.ReturnStmt(e,t,n)}parseExpression(){return this.parseAssignment()}parseAssignment(){let e=this.parseLogicOr();if(this.match("EQUAL")){const t=this.consume();if(e instanceof r.VariableExpr){const t=this.parseAssignment();return new r.AssignExpr(e.lToken,t)}if(e instanceof r.ArrayAccessExpr){const t=this.parseAssignment();return new r.ArrayAssignExpr(e,t)}throw new s.TokenError("Trying to assign to invalid target.",t)}return e}parseLogicOr(){let e=this.parseLogicAnd();if(this.match("OR")){const t=e,n=this.consume(),s=this.parseExpression();return new r.LogicalExpr(t,n,s)}return e}parseLogicAnd(){let e=this.parseEquality();if(this.match("AND")){const t=e,n=this.consume(),s=this.parseExpression();return new r.LogicalExpr(t,n,s)}return e}parseEquality(){return this.parseBinary((()=>this.parseComparison()),"BANG_EQUAL","EQUAL_EQUAL")}parseComparison(){return this.parseBinary((()=>this.parseTerm()),"LESS","LESS_EQUAL","GREATER","GREATER_EQUAL")}parseTerm(){return this.parseBinary((()=>this.parseFactor()),"MINUS","PLUS")}parseFactor(){return this.parseBinary((()=>this.parseUnary()),"SLASH","STAR","PERCENT")}parseUnary(){if(this.match("BANG","MINUS")){const e=this.consume(),t=this.parseUnary();return new r.UnaryExpr(e,t)}return this.parseCallOrAccess()}parseCallOrAccess(){let e=this.parsePrimary();for(;this.match("LEFT_PAREN","LEFT_BRACKET");)this.match("LEFT_PAREN")&&(e=this.parseCall(e)),this.match("LEFT_BRACKET")&&(e=this.parseArrayAccess(e));return e}parseCall(e){this.expect("LEFT_PAREN","Expect '(' for call.");let t=[];if(!this.match("RIGHT_PAREN"))do{t.push(this.parseExpression())}while(this.matchAndConsume("COMMA"));const n=this.expect("RIGHT_PAREN","Expect ')' after arguments.");return new r.CallExpr(e,n,t)}parseArrayAccess(e){this.expect("LEFT_BRACKET","Expect '[' for array access.");const t=this.parseExpression(),n=this.expect("RIGHT_BRACKET","Expect ']' for array access.");return new r.ArrayAccessExpr(e,t,n)}parsePrimary(){if(this.match("NUMBER","STRING","TRUE","FALSE")){const e=this.consume();return new r.LiteralExpr(e.value,e)}if(this.match("FUNCTION"))return this.parseFunctionObject();if(this.match("LEFT_BRACKET"))return this.parseArrayObject();if(this.match("IDENTIFIER"))return new r.VariableExpr(this.consume());if(this.match("LEFT_PAREN")){const e=this.consume(),t=this.parseExpression(),n=this.expect("RIGHT_PAREN","Expect ')' after expression.");return new r.GroupingExpr(n,t,e)}throw new s.TokenError("Expect expression.",this.peek())}parseFunctionObject(){const e=this.expect("FUNCTION","Expect 'fn' for function object.");this.expect("LEFT_PAREN","Expect '(' after 'fn'.");let t=[],n=[],s=!1;for(;!this.match("RIGHT_PAREN");){s&&this.expect("COMMA","Expect comma between parameters.");const e=this.expect("IDENTIFIER","Expect identifier.");this.expect("COLON","Expect colon after identifier.");const r=this.parseObjectType();t.push(e),n.push(r),s=!0}this.consume(),this.expect("RIGHTARROW","Expect '=>' after parameters.");const i=this.parseObjectType(),a=this.parseStatement();return new r.FunctionObjectExpr(t,n,i,a,e)}parseBinary(e,...t){let n=e();for(;this.match(...t);){const t=n,s=this.consume(),i=e();n=new r.BinaryExpr(t,s,i)}return n}parseArrayObject(){const e=this.expect("LEFT_BRACKET","Expect left bracket for array start.");if(this.match("RIGHT_BRACKET")){const t=this.consume(),n="An empty array cannot be made in this way.";throw new s.TokenRangeError(n,e,t)}const t=this.parseExpression();if(this.match("RIGHT_BRACKET")){const n=this.consume(),s=1,i=[t];return new r.ArrayObjectExpr(s,i,e,n)}return this.match("COMMA")?this.parseFilledArray(e,t):this.parseLengthArray(e,t)}parseFilledArray(e,t){const n=[t];for(;!this.isAtEnd()&&!this.match("RIGHT_BRACKET");){this.expect("COMMA","Expect comma.");const e=this.parseExpression();n.push(e)}const s=this.expect("RIGHT_BRACKET","Expect right bracket."),i=n.length;return new r.ArrayObjectExpr(i,n,e,s)}parseLengthArray(e,t){this.expect("OF","Expect 'of' after length expression.");const n=this.parseExpression(),s=this.expect("RIGHT_BRACKET","Expect right bracket.");return new r.ArrayObjectExpr(t,n,e,s)}parseObjectType(){const e=this.peek().type;return["NUMBER_PRIMITIVE_TYPE","STRING_PRIMITIVE_TYPE","BOOL_PRIMITIVE_TYPE"].includes(e)?new a.LiteralTypeExpr(this.consume()):"LEFT_BRACKET"===e?this.parseArrayObjectType():this.parseFunctionObjectType()}parseFunctionObjectType(){const e=this.expect("LEFT_PAREN","Expect '(' for function type.");let t,n=[],r=!1;for(;!this.match("RIGHT_PAREN");)r&&this.expect("COMMA","Expect comma between parameters."),n.push(this.parseObjectType()),r=!0;return this.expect("RIGHT_PAREN","Expect ')' after parameters."),this.expect("RIGHTARROW","Expect '=>' for function type."),t=this.parseObjectType(),new a.FunctionTypeExpr(e,n,t)}parseArrayObjectType(){const e=this.expect("LEFT_BRACKET","Expect '[' for array type."),t=this.parseObjectType(),n=this.expect("RIGHT_BRACKET","Expect ']' for array type.");return new a.ArrayTypeExpr(e,t,n)}peek(){return this.tokens[this.currentIndex]}consume(){return this.tokens[this.currentIndex++]}expect(e,t){if(this.peek().type===e)return this.consume();throw new s.TokenError(t,this.peek())}match(...e){for(const t of e)if(this.peek().type===t)return!0;return!1}matchAndConsume(...e){for(const t of e)if(this.peek().type===t)return this.consume(),!0;return!1}isAtEnd(){return"EOF"===this.peek().type}}},177:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const r=n(522),s=n(101);t.default=class{constructor(e,t){this.interpreter=e,this.typeValidator=t,this.initializedVariablesScopes=[]}resolveProgram(e){this.resolveStatements(e)}visitBlockStmt(e){this.beginScope(),this.resolveStatements(e.statements),this.endScope()}visitDeclarationStmt(e){let t=e.initialValue;for(;t instanceof s.GroupingExpr;)t=t.expression;t instanceof s.FunctionObjectExpr?(this.declare(e.identifier),this.define(e.identifier),this.resolveExpression(t)):(this.declare(e.identifier),this.resolveExpression(t),this.define(e.identifier))}visitExpressionStmt(e){this.resolveExpression(e.expression)}visitIfStmt(e){this.resolveExpression(e.condition),this.resolveStatement(e.thenBranch),null!==e.elseBranch&&this.resolveStatement(e.elseBranch)}visitPrintStmt(e){this.resolveExpression(e.expression)}visitReturnStmt(e){null!==e.value&&this.resolveExpression(e.value)}visitWhileStmt(e){this.resolveExpression(e.condition),this.resolveStatement(e.body)}visitBlankStmt(e){}visitBreakStmt(e){}visitVariableExpr(e){const t=this.initializedVariablesScopes.length-1,n=this.initializedVariablesScopes[t];if(this.initializedVariablesScopes.length>0&&!1===n.get(e.lToken.lexeme)){const t="Can't read local variable in its own initializer.";throw new r.SyntaxTreeNodeError(t,e)}this.resolveLocalVariable(e,e.lToken.lexeme)}visitAssignExpr(e){this.resolveExpression(e.value),this.resolveLocalVariable(e,e.lToken.lexeme)}visitFunctionObjectExpr(e){this.resolveFunction(e)}visitArrayAccessExpr(e){this.resolveExpression(e.arrayExpr),this.resolveExpression(e.index)}visitArrayAssignExpr(e){this.resolveExpression(e.arrayAccessExpr),this.resolveExpression(e.assignmentValue)}visitArrayObjectExpr(e){if(e.capacity instanceof s.Expr&&this.resolveExpression(e.capacity),Array.isArray(e.elements))for(const t of e.elements)this.resolveExpression(t);else this.resolveExpression(e.elements)}visitBinaryExpr(e){this.resolveExpression(e.leftExpr),this.resolveExpression(e.rightExpr)}visitCallExpr(e){this.resolveExpression(e.callee);for(const t of e.args)this.resolveExpression(t)}visitGroupingExpr(e){this.resolveExpression(e.expression)}visitLiteralExpr(e){}visitLogicalExpr(e){this.resolveExpression(e.leftExpr),this.resolveExpression(e.rightExpr)}visitUnaryExpr(e){this.resolveExpression(e.rightExpr)}beginScope(){this.initializedVariablesScopes.push(new Map)}endScope(){this.initializedVariablesScopes.pop()}resolveStatement(e){e.accept(this)}resolveStatements(e){for(const t of e)this.resolveStatement(t)}resolveExpression(e){e.accept(this)}resolveFunction(e){this.beginScope();for(const t of e.parameterTokens)this.declare(t),this.define(t);this.resolveStatement(e.statement),this.endScope()}resolveLocalVariable(e,t){const n=this.initializedVariablesScopes;for(let r=n.length-1;r>=0;r--)if(n[r].has(t))return this.interpreter.resolve(e,n.length-1-r),void this.typeValidator.resolve(e,n.length-1-r)}declare(e){if(0===this.initializedVariablesScopes.length)return;const t=this.initializedVariablesScopes.length-1;this.initializedVariablesScopes[t].set(e.lexeme,!1)}define(e){if(0===this.initializedVariablesScopes.length)return;const t=this.initializedVariablesScopes.length-1;this.initializedVariablesScopes[t].set(e.lexeme,!0)}}},615:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(n(396)),i=r(n(824)),a=r(n(975)),o=r(n(219)),c=r(n(177)),l=n(522);t.default=function(e){let t="";const n=new s.default(e);let r;try{r=n.scan()}catch(e){if(!Array.isArray(e))throw e;for(const n of e)t+=`${n.toString()}\n\n`;return[t,!0]}const h=new i.default(r);let p;try{p=h.parse()}catch(e){if(!Array.isArray(e))throw e;for(const n of e)t+=`${n.toString()}\n\n`;return[t,!0]}const u=new o.default(p),E=new a.default(p);new c.default(u,E).resolveProgram(p);try{E.validateProgram()}catch(e){if(!Array.isArray(e))throw e;for(const n of e)t+=`${n.toString()}\n\n`;return[t,!0]}try{t+=u.interpret()}catch(e){if(!(e instanceof l.LangError))throw e;return t+="Runtime error:\n\n",t+=e.toString(),[t,!0]}return[t,!1]}},396:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const r=n(522),s=n(104),i=new Map([["and","AND"],["break","BREAK"],["do","DO"],["else","ELSE"],["false","FALSE"],["for","FOR"],["fn","FUNCTION"],["if","IF"],["of","OF"],["or","OR"],["print","PRINT"],["return","RETURN"],["then","THEN"],["true","TRUE"],["let","LET"],["while","WHILE"],["num","NUMBER_PRIMITIVE_TYPE"],["str","STRING_PRIMITIVE_TYPE"],["bool","BOOL_PRIMITIVE_TYPE"]]);t.default=class{constructor(e){this.source=e.replaceAll("\t","  ").replaceAll("\r"," "),this.sourceLines=e.split("\n"),this.tokens=[],this.start=0,this.current=0,this.line=1,this.lineStart=0,this.errors=[]}scan(){for(;!this.isAtEnd();)this.scanToken();if(this.errors.length>0)throw this.errors;const e=this.sourceLines[this.sourceLines.length-1].length,t=new s.Token("EOF","",null,this.sourceLines[this.line-1],this.line,e);return this.tokens.push(t),this.tokens}scanToken(){this.start=this.current;const e=this.consume();switch(e){case"(":this.addToken("LEFT_PAREN");break;case")":this.addToken("RIGHT_PAREN");break;case"{":this.addToken("LEFT_BRACE");break;case"}":this.addToken("RIGHT_BRACE");break;case"[":this.addToken("LEFT_BRACKET");break;case"]":this.addToken("RIGHT_BRACKET");break;case",":this.addToken("COMMA");break;case".":this.addToken("DOT");break;case"-":this.addToken("MINUS");break;case"+":this.addToken("PLUS");break;case";":this.addToken("SEMICOLON");break;case"*":this.addToken("STAR");break;case"%":this.addToken("PERCENT");break;case":":this.addToken("COLON");break;case"!":this.addToken(this.consumeIfMatching("=")?"BANG_EQUAL":"BANG");break;case"=":if("="==this.peek()){this.consume(),this.addToken("EQUAL_EQUAL");break}if(">"==this.peek()){this.consume(),this.addToken("RIGHTARROW");break}this.addToken("EQUAL");break;case"<":this.addToken(this.consumeIfMatching("=")?"LESS_EQUAL":"LESS");break;case">":this.addToken(this.consumeIfMatching("=")?"GREATER_EQUAL":"GREATER");break;case"/":this.consumeIfMatching("/")?this.scanOneLineComment():this.consumeIfMatching("*")?this.scanMultiLineComment():this.addToken("SLASH");break;case" ":case"\n":break;case'"':case"'":this.scanString();break;default:if(this.isDigit(e))this.scanNumber();else if(this.isAlphaOrUnderscore(e))this.scanIdentifierOrKeyword();else{const t=`Unexpected character ${e}.`,n=this.start-this.lineStart+1;this.addError(t,this.line,n)}}}scanOneLineComment(){for(;"\n"!=this.peek()&&!this.isAtEnd();)this.consume()}scanMultiLineComment(){let e=1;for(;e>0&&!this.isAtEnd();){const t=this.consume();"/"===t&&this.consumeIfMatching("*")&&e++,"*"===t&&this.consumeIfMatching("/")&&e--}}scanString(){const e=this.source[this.start],t=this.line,n=this.start-this.lineStart+1;let r="";for(;!this.isAtEnd()&&this.peek()!==e;)r+=this.consume();this.isAtEnd()?this.addError("Unterminated string.",t,n):(this.consume(),this.addToken("STRING",r))}scanNumber(){for(;this.isDigit(this.peek());)this.consume();let e;if(e=this.isAtEnd(this.current+1)?"\0":this.source[this.current+1],"."===this.peek()&&this.isDigit(e))for(this.consume();this.isDigit(this.peek());)this.consume();const t=this.getCurrentLexeme();this.addToken("NUMBER",parseFloat(t))}scanIdentifierOrKeyword(){for(;this.isAlphaOrUnderscore(this.peek())||this.isDigit(this.peek());)this.consume();const e=this.getCurrentLexeme();let t=i.get(e);void 0===t&&(t="IDENTIFIER"),"TRUE"!==t?"FALSE"!==t?this.addToken(t):this.addToken(t,!1):this.addToken(t,!0)}isAtEnd(e=this.current){return e>=this.source.length}consume(){const e=this.peek();return this.current++,"\n"===e&&(this.line++,this.lineStart=this.current),e}peek(){return this.isAtEnd()?"\0":this.source[this.current]}consumeIfMatching(e){return!this.isAtEnd()&&this.source[this.current]==e&&(this.consume(),!0)}addToken(e,t=null){const n=this.getCurrentLexeme(),r=this.start-this.lineStart+1;this.tokens.push(new s.Token(e,n,t,this.sourceLines[this.line-1],this.line,r))}isDigit(e){return e>="0"&&e<="9"}isAlphaOrUnderscore(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"||"_"===e}addError(e,t,n){const s=this.sourceLines[t-1];this.errors.push(new r.CharacterError(e,s,t,n))}getCurrentLexeme(){return this.source.substring(this.start,this.current)}}},46:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.WhileStmt=t.DeclarationStmt=t.ReturnStmt=t.PrintStmt=t.IfStmt=t.ExpressionStmt=t.BlockStmt=t.BreakStmt=t.BlankStmt=t.Stmt=void 0;const s=r(n(871));class i extends s.default{}t.Stmt=i,t.BlankStmt=class extends i{constructor(e){super(e,e)}accept(e){return e.visitBlankStmt(this)}},t.BreakStmt=class extends i{constructor(e,t){super(e,t)}accept(e){return e.visitBreakStmt(this)}},t.BlockStmt=class extends i{constructor(e,t,n){super(e,n),this.statements=t}accept(e){return e.visitBlockStmt(this)}},t.ExpressionStmt=class extends i{constructor(e,t){super(e.lToken,t),this.expression=e}accept(e){return e.visitExpressionStmt(this)}},t.IfStmt=class extends i{constructor(e,t,n,r=null){super(e,null!==r?r.rToken:n.rToken),this.condition=t,this.thenBranch=n,this.elseBranch=r}accept(e){return e.visitIfStmt(this)}},t.PrintStmt=class extends i{constructor(e,t,n){super(e,n),this.expression=t}accept(e){return e.visitPrintStmt(this)}},t.ReturnStmt=class extends i{constructor(e,t,n){super(e,n),this.value=t}accept(e){return e.visitReturnStmt(this)}},t.DeclarationStmt=class extends i{constructor(e,t,n,r,s){super(e,s),this.identifier=t,this.type=n,this.initialValue=r}accept(e){return e.visitDeclarationStmt(this)}},t.WhileStmt=class extends i{constructor(e,t,n){super(e,n.rToken),this.condition=t,this.body=n}accept(e){return e.visitWhileStmt(this)}}},871:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e,t){this.lToken=e,this.rToken=t}}},104:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Token=void 0,t.Token=class{constructor(e,t,n,r,s,i){this.type=e,this.lexeme=t,this.value=n,this.lineString=r,this.lineIndex=s,this.column=i}toString(){return this.type+" "+this.lexeme+" "+this.value}}},667:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.LiteralTypeExpr=t.FunctionTypeExpr=t.ArrayTypeExpr=t.TypeExpr=void 0;const s=r(n(871));class i extends s.default{}t.TypeExpr=i,t.ArrayTypeExpr=class extends i{constructor(e,t,n){super(e,n),this.innerType=t}accept(e){return e.visitArrayTypeExpr(this)}},t.FunctionTypeExpr=class extends i{constructor(e,t,n){super(e,n.rToken),this.parameterTypes=t,this.returnType=n}accept(e){return e.visitFunctionTypeExpr(this)}},t.LiteralTypeExpr=class extends i{constructor(e){super(e,e),this.token=e}accept(e){return e.visitLiteralTypeExpr(this)}}},975:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=n(101),i=n(522),a=n(746),o=r(n(556));t.default=class{constructor(e){this.program=e,this.globalEnvironment=new o.default(null),this.currentEnvironment=this.globalEnvironment,this.functionEnvironment=null,this.expectedTypeStack=[],this.withinIf=!1,this.withinWhile=!1,this.currentReturnType=null,this.localVariableDistances=new Map}validateProgram(){const e=[];for(const t of this.program)try{this.validateStatement(t)}catch(t){if(!(t instanceof i.LangError))throw t;e.push(t)}if(e.length>0)throw e}validateStatement(e){e.accept(this)}validateExpression(e){return e.accept(this)}visitPrintStmt(e){this.validateExpression(e.expression)}visitExpressionStmt(e){this.validateExpression(e.expression)}visitBlankStmt(e){}visitDeclarationStmt(e){let t,n=e.initialValue;for(;n instanceof s.GroupingExpr;)n=n.expression;if(n instanceof s.FunctionObjectExpr){const t=this.validateExpression(n.returnType),r=[];for(const e of n.parameterTypes)r.push(this.validateExpression(e));this.currentEnvironment.define(e.identifier.lexeme,new a.FunctionLangType(r,t))}t=null===e.type?null:this.validateExpression(e.type);const r=this.validateExpression(n);if(null!==t&&!(0,a.LangTypeEqual)(t,r))throw new i.SyntaxTreeNodeError("Types do not match in declaration.",e);this.currentEnvironment.define(e.identifier.lexeme,r)}visitBlockStmt(e){const t=this.currentEnvironment;this.currentEnvironment=new o.default(t);try{for(const t of e.statements)this.validateStatement(t)}finally{this.currentEnvironment=t}}visitIfStmt(e){const t=this.withinIf;if(this.withinIf=!0,"Bool"!==this.validateExpression(e.condition))throw new i.TokenError("If statement condition must be a bool.",e.lToken);this.validateStatement(e.thenBranch),null!==e.elseBranch&&this.validateStatement(e.elseBranch),this.withinIf=t}visitWhileStmt(e){const t=this.withinWhile;if(this.withinWhile=!0,"Bool"!==this.validateExpression(e.condition))throw new i.SyntaxTreeNodeError("Condition must be a bool.",e.condition);this.validateStatement(e.body),this.withinWhile=t}visitBreakStmt(e){if(!this.withinIf&&!this.withinWhile)throw new i.TokenError("Cannot break outside of an if or while statement.",e.lToken)}visitReturnStmt(e){if(0===this.expectedTypeStack.length)throw new i.SyntaxTreeNodeError("Cannot return outside of function.",e);const t=this.validateExpression(e.value);if(!this.withinIf&&!this.withinWhile){if(null!==this.currentReturnType)throw new i.SyntaxTreeNodeError("Unexpected return statement.",e);this.currentReturnType=t}}visitBinaryExpr(e){const t=e.operator.type;if(this.tokenTypeMatch(t,"EQUAL_EQUAL","BANG_EQUAL")){const t=this.validateExpression(e.leftExpr),n=this.validateExpression(e.rightExpr);if(t instanceof a.ComplexLangType){const t="Left expression type must be num, str, or bool";throw new i.SyntaxTreeNodeError(t,e.leftExpr)}if(n instanceof a.ComplexLangType){const t="Right expression type must be num, str, or bool";throw new i.SyntaxTreeNodeError(t,e.rightExpr)}if(t!==n)throw new i.TokenError("Types do not match.",e.operator);return"Bool"}if(this.tokenTypeMatch(t,"LESS","LESS_EQUAL","GREATER","GREATER_EQUAL")){if("Num"!==this.validateExpression(e.leftExpr))throw new i.SyntaxTreeNodeError("Left operand is not a number.",e.leftExpr);if("Num"!==this.validateExpression(e.rightExpr))throw new i.SyntaxTreeNodeError("Right operand is not a number.",e.rightExpr);return"Bool"}if(this.tokenTypeMatch(t,"MINUS","STAR","SLASH","PERCENT")){if("Num"!==this.validateExpression(e.leftExpr))throw new i.SyntaxTreeNodeError("Left operand is not a number.",e.leftExpr);if("Num"!==this.validateExpression(e.rightExpr))throw new i.SyntaxTreeNodeError("Right operand is not a number.",e.rightExpr);return"Num"}if(this.tokenTypeMatch(t,"PLUS")){const t=this.validateExpression(e.leftExpr);if("Num"!==t&&"Str"!==t)throw new i.SyntaxTreeNodeError("Left operand is not a number or string.",e.leftExpr);const n=this.validateExpression(e.rightExpr);if("Num"!==n&&"Str"!==n)throw new i.SyntaxTreeNodeError("Right operand is not a number or string.",e.rightExpr);return n}throw new i.ImplementationError("Unknown operator in binary expression.")}visitUnaryExpr(e){const t=e.operator.type;if(this.tokenTypeMatch(t,"MINUS")){if("Num"!=this.validateExpression(e.rightExpr))throw new i.SyntaxTreeNodeError("Operand is not a number.",e.rightExpr);return"Num"}if(this.tokenTypeMatch(t,"BANG")){if("Bool"!=this.validateExpression(e.rightExpr))throw new i.SyntaxTreeNodeError("Operand is not a number.",e.rightExpr);return"Bool"}throw new i.ImplementationError("Unknown operator in unary expression.")}visitGroupingExpr(e){return this.validateExpression(e.expression)}visitLiteralExpr(e){return"number"==typeof e.value?"Num":"string"==typeof e.value?"Str":"Bool"}visitVariableExpr(e){const t=this.currentEnvironment.get(e.lToken.lexeme);if(void 0===t)throw new i.TokenError("Undefined variable.",e.lToken);return t}visitAssignExpr(e){const t=e.lToken,n=t.lexeme,r=this.currentEnvironment.get(n);if(void 0===r)throw new i.TokenError("Undefined variable.",t);const s=this.validateExpression(e.value),o=r;if(!(0,a.LangTypeEqual)(o,s))throw new i.SyntaxTreeNodeError("Types do not match in assignment.",e);return o}visitLogicalExpr(e){if("Bool"!=this.validateExpression(e.leftExpr))throw new i.SyntaxTreeNodeError("Left operand must be a bool.",e.leftExpr);if("Bool"!=this.validateExpression(e.rightExpr))throw new i.SyntaxTreeNodeError("Right operand must be a bool.",e.rightExpr);return"Bool"}visitFunctionObjectExpr(e){const t=this.currentEnvironment,n=this.withinIf,r=this.withinWhile,s=this.currentReturnType;this.withinIf=!1,this.withinWhile=!1,this.currentReturnType=null;const c=this.validateExpression(e.returnType),l=[];this.expectedTypeStack.push(c);const h=new o.default(t);for(const t in e.parameterTokens){const n=e.parameterTokens[t].lexeme,r=this.validateExpression(e.parameterTypes[t]);l.push(r),h.define(n,r)}this.currentEnvironment=h;try{this.validateStatement(e.statement)}finally{this.currentEnvironment=t}const p=this.expectedTypeStack.pop();if((0,a.LangTypeEqual)(p,this.currentReturnType))return this.withinIf=n,this.withinWhile=r,this.currentReturnType=s,new a.FunctionLangType(l,c);throw this.withinIf=n,this.withinWhile=r,this.currentReturnType=s,new i.SyntaxTreeNodeError("Invalid return type",e.statement)}visitCallExpr(e){const t=this.validateExpression(e.callee);if(!(t instanceof a.FunctionLangType))throw new i.SyntaxTreeNodeError("Expect callable object.",e.callee);const n=e.args;let r=[];for(const e of n)r.push(this.validateExpression(e));const s=t.parameters;if(s.length!=r.length){const t="Number of arguments does not equal number of parameters";throw new i.SyntaxTreeNodeError(t,e)}for(const t in s)if(!(0,a.LangTypeEqual)(s[t],r[t])){const t="Invalid argument type(s)";throw new i.SyntaxTreeNodeError(t,e)}return t.returnType}visitArrayObjectExpr(e){if(e.capacity instanceof s.Expr&&"Num"!==this.validateExpression(e.capacity))throw new i.SyntaxTreeNodeError("Given capacity must be a number.",e.capacity);let t;if(Array.isArray(e.elements)){t=this.validateExpression(e.elements[0]);for(const n of e.elements){const r=this.validateExpression(n);if(!(0,a.LangTypeEqual)(t,r))throw new i.SyntaxTreeNodeError("Types must all be the same in an array",e)}}else t=this.validateExpression(e.elements);return new a.ArrayLangType(t)}visitArrayAccessExpr(e){if("Num"!==this.validateExpression(e.index))throw new i.SyntaxTreeNodeError("Expect index number.",e);const t=this.validateExpression(e.arrayExpr);if(!(t instanceof a.ArrayLangType))throw new i.SyntaxTreeNodeError("Only arrays can be accessed via [].",e);return t.innerType}visitArrayAssignExpr(e){const t=this.validateExpression(e.arrayAccessExpr),n=this.validateExpression(e.assignmentValue);if(!(0,a.LangTypeEqual)(t,n))throw new i.SyntaxTreeNodeError("Types do not match in assignment",e);return n}visitArrayTypeExpr(e){const t=this.validateExpression(e.innerType);return new a.ArrayLangType(t)}visitFunctionTypeExpr(e){const t=[];for(const n of e.parameterTypes)t.push(this.validateExpression(n));const n=this.validateExpression(e.returnType);return new a.FunctionLangType(t,n)}visitLiteralTypeExpr(e){switch(e.token.type){case"NUMBER_PRIMITIVE_TYPE":return"Num";case"BOOL_PRIMITIVE_TYPE":return"Bool";case"STRING_PRIMITIVE_TYPE":return"Str";default:throw new i.ImplementationError("Unknown LiteralTypeExpr token.")}}tokenTypeMatch(e,...t){for(const n of t)if(n==e)return!0;return!1}resolve(e,t){this.localVariableDistances.set(e,t)}}},885:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0});t.default={"1 - Introduction":"// Welcome to the playground for MFL, 'My First Language', a statically-typed\n// scripting language written in Typescript.\n\nprint 'Hello, world!';\nprint 'Use the run button above to run any code written here.';\nprint 'Use the dropdown menu above to tour the language.';\n","2 - Statements":"// MFL programs consist of statements ending with a closing semicolon.\n\n// Print statements use the built-in 'print' keyword.\nprint 'hello';\n\n// Variables can be declared with 'let'. The types will be discussed later.\nlet x = 69; let y = 'im a string'; let z = true;\nprint x; print y; print z;\n\n// Variables can then be assigned.\nx = 5; y = 'hello'; z = false;\nprint x; print y; print z;\n\n// Block statements are wrapped in '{' and '}' and have their own scope.\nlet x = 'outer'; let y = 'outer';\n{\n  let x = 'inner, not outer';\n  print x; print y;\n}\n\n// If-else statements use a 'if' statement 'then' statement 'else' syntax.\nif 1 > 0 then print 'yes';\n\nif 1 > 0 then\n  print 'yes';\nelse\n  print 'no';\n\n// WARNING: be sure to use '{' and '}' for multi-line statements\nif true then {\n  print 'line 1';\n  print 'line 2';\n}\n\n// While loops use a 'while' condition 'do' statement syntax.\nlet i = 0;\nwhile i < 5 do {\n  print i;\n  i = i + 1;\n}\n\n// Use the 'break' keyword to escape a while loop.\nwhile true do {\n  print 'forever?';\n  break;\n}\nprint 'nope';\n\n// Finally, C-style comments are supported.\n\n// this is a one-line comment\n/* this is a multi-line comment */\n/* this is a /* nested */ comment */\n","3 - Types":"// The primitive variable types are numbers, strings, and booleans. The types can\n// be hinted ('num' for number, 'str' for string, 'bool' for boolean).\nlet a: num = 0;\nlet b: num = 1.5;\nlet c: str = 'string';\nlet d: bool = true;\n\n// These statements are commented out, but will result in type-checking errors.\n/*\nlet a: num = true;\nlet b: str = 5;\n*/\n\n// Types are not mutable, since the language is statically-typed.\n/*\nlet n: num = 5;\nn = 'string'; // error here\n*/\nlet n: num = 5;\nlet n: str = 'string'; // this is fine\n\n// Type inference is supported, so hints can be omitted.\nlet x = 5; // x is a num\nlet y = true; // y is a bool\n\n// Basic arithmetic operators are supported, as well as negative numbers.\nprint (((1 + 1) / 2) * 5) - 1;\nprint -0.5 / 1.2;\n\n// The standard relations are also supported.\nprint 1 > 0;\nprint 1 >= 0;\nprint 1 < 0;\nprint 1 <= 0;\nprint 1 == 0;\nprint 1 != 0;\n\n// Strings can be concatenated to other strings and numbers using '+'.\nprint 'abc' + 'def';\nprint 'one' + 2 + 'three';\n\n// The basic boolean operators are supported.\nprint true or false;\nprint true and false;\n\n// There are two other types not shown here, functions and arrays. They are the\n// subjects of the next sections.\n","4 - Functions":"// Functions are created with the 'fn' keyword, and are anonymous (unnamed) by\n// default. The following anonymous function expressions sit in their own\n// statements, and so the ending semicolons are necessary.\n\n// This is a function that returns a string.\n// NOTE the return type must be specified.\nfn() => str { return 'a string'; } ;\n\n// This is a function that takes a number and returns it.\n// NOTE the types of the parameters must be specified.\nfn(x: num) => num { return x; } ;\n\n// Functions are first-class objects, and can be assigned to variables so that\n// they can be called.\n// NOTE void functions are not supported.\nlet returnHello = fn() => str {\n  return 'hello';\n};\nprint returnHello();\n\nlet addNums = fn(x: num, y: num) => num {\n  return x + y;\n};\nprint addNums(1, 2);\n\n// Anonymous functions can be called without being assigned to a variable.\nprint ( fn() => num { return 0; } )();\n\n// Functions can be type-hinted too using () => notation.\nlet conditionalPrint: (num, str) => str =\nfn(x: num, message: str) => str {\n  if x > 0 then return 'x greater than 0';\n  return message;\n};\nprint conditionalPrint(1, 'i wont get printed');\nprint conditionalPrint(0, 'i will get printed');\n\n// Functions can return other functions, since functions are first-class.\n// NOTE this function returns a function taking no arguments and returning a num\nlet returnAFunctionThatReturnsFive =\nfn() => () => num { \n  return fn() => num { return 5; } ;\n};\nlet returnFive = returnAFunctionThatReturnsFive();\nprint returnFive();\n\n// Naturally, functions can also take other functions as arguments.\nlet returnSumOfOutputs = fn(func1: () => num, func2: () => num) => num {\n  return func1() + func2();\n};\nprint returnSumOfOutputs(returnFive, returnFive);\n\n// Recursion works too. Here's the first 25 fibonacci numbers.\nlet fib = fn(n: num) => num {\n  if n <= 1 then return n;\n  return fib(n - 1) + fib(n - 2);\n};\n\n// WARNING: setting max to > 30 or so will make the loop take a long time\nlet max = 25;\nlet i = 1;\nwhile i <= max do {\n  print i + ': ' + fib(i);\n  i = i + 1;\n}\n","5 - Arrays":"// Arrays are also first-class objects. They can be created by specifying the\n// elements in brackets or by providing a number along with an expression\nprint [ 1, 2, 3 ];\nprint [ 'a', 'b', 'c' ];\nprint [ 5 of true ];\n\nlet fnArr = [ fn () => num { return 0; }, fn () => num { return 1; } ];\nprint fnArr[0]();\nprint fnArr[1]();\n\n// Array types given by wrapping '[' and ']' around the inner type in the array\nlet arr1: [ num ] = [ 1, 2, 3 ];\nlet arr2: [ str ] = [ 'a', 'b', 'c' ];\nlet arr3: [ bool ] = [ 5 of true ];\n\nlet getFirstNum = fn (arr: [ num ]) => num {\n  return arr[0];\n};\nprint getFirstNum([3, 2, 1, 0]);\n\n// NOTE empty arrays can only be specified using 0 along with some expression\n/*\nlet arr = []; // this won't work because the type of the array is unknown\n*/\nlet emptyNumArr = [ 0 of 0 ]; // this is fine, the type is [ num ]\nlet emptyStrArr = [ 0 of '' ]; // this is fine too, the type is [ str ]\nprint emptyNumArr; print emptyStrArr;\n\n// Array values can be reassigned by specifying the index\nlet arr = [ 0, 1 ]; print arr;\narr[0] = 1; print arr;\n\nlet arr = [[ 0, 0 ], [ 0, 0 ]]; print arr;\narr[0][1] = 4; print arr;\n\n// Arrays can only contain a single type, and they are not dynamic, in other\n// words the capacity cannot be changed\nlet arr: [ num ] = [ 0, 1, 2 ];\n/*\narr[0] = 'a'; // error, type of an element must be a num\narr[3] = 3; // error, index out of range\n*/\n\n// Arrays can contain other arrays, allowing for multi-dimensional arrays\nlet arr: [[ str ]] = [3 of [ 'dog', 'cat' ]];\nlet idMatrix: [[ num ]] = [[ 1, 0, 0],\n                           [ 0, 1, 0],\n                           [ 0, 0, 1]];\n\n// NOTE the reason why fixed-length arrays are the only supported data structure\n// is because other common data structures, linked lists, dictionaries, dynamic \n// arrays, etc. can be built in the language using fixed-length arrays and\n// classes. Unfortunately, classes are not supported at the moment.\n","6 - Error Messages":"// Here are some errors to demonstrate the serviceable error reporting system.\n\n// error at a range of tokens on one line\nlet x: str = 5;\n\n// error at a range of tokens on two consecutive lines\nlet x: str =\n5;\n\n// error at a range of tokens on more than two lines\nlet x: str\n=\n5;\n\nlet x:\nstr\n=\n5;\n","Extra - Bugs and Limitations":"// Return types must be explicitly declared outside of an if-else statement.\n","Extra - Grammar":'/*\nBelow is the grammar for the language, written in a BNF-like way.\n\nprogram             → statement* EOF ;\n\n// statements\n\nstatement         → ifStmt | blockStmt | whileStmt |\n                  ( ( declarationStmt | printStmt | exprStmt | returnStmt )? ";" ) ;\nifStmt            → "if" expression "then" statement ( "else" statement )? ;\nblockStmt         → "{" statement* "}" ;\nwhileStmt         → "while" condition then statement\ndeclarationStmt   → "let" IDENTIFIER ( ":" objectType )? "=" expression ;\nexprStmt          → expression ;\nprintStmt         → "print" expression ;\nreturnStmt        → "return" expression ;\n\n// types\n\nobjectType        → "number" | "string" | "bool" | functionType | arrayType ;\nfunctionType      → "(" ( ( objectType "," )* objectType )? ")" "=>"\n                    ( objectType | "void" ) ;\narrayType         → "[" objectType "]"\n\n// expressions\n\nexpression        → assignment ;\nassignment        → IDENTIFIER "=" assignment |\n                    callOrAccess "=" assignment |\n                    logic_or ;\nlogic_or          → logic_and ( "or" expression )* ;\nlogic_and         → equality ( "and" expression )* ;\nequality          → comparison ( ( "!=" | "==" ) comparison )* ;\ncomparison        → term ( ( ">" | ">=" | "<" | "<=" ) term )* ;\nterm              → factor ( ( "-" | "+" ) factor )* ;\nfactor            → unary ( ( "/" | "*" | "%" ) unary )* ;\nunary             → ( "!" | "-" ) unary | call ;\ncallOrAccess      → primary ( arrayAccess | call )* ;\narrayAccess       → "[" expression "]" ;\ncall              → "(" ( expression ( "," expression)* )? ")" ;\nprimary           → NUMBER | STRING | "true" | "false" | functionObject |\n                    arrayObject | IDENTIFIER | "(" expression ")" ;\nfunctionObject    → "fn" "(" ( ( IDENTIFIER ":" objectType "," )* \n                    ( IDENTIFIER ":" objectType) )? ")" \n                    "=>" objectType statement\narrayObject       → filledArray | lengthArray ;\nfilledArray       → "[" ( expression (( "," expression )* )? )? "]"\nlengthArray       → "[" expression "of" expression "]" ;\n*/\n',"Extra - Implementation Details":"// Under the hood, the language is written in Typescript (compiled to\n// Javascript) and implemented as a tree-walk interpreter.\n\n// The source code can be found here: <link>\n\n// The web client is also written with no dependencies. It uses some HTML/CSS\n// hacks to get the left-side text input to feel like an editor.\n","Fizz Buzz":"// an implementation of Fizz Buzz (https://en.wikipedia.org/wiki/Fizz_buzz)\n\nlet i = 0;\nwhile (i <= 100) do {\n  if (i % 3 == 0 and i % 5 == 0) then print 'Fizz Buzz';\n  else if (i % 3 == 0) then print 'Fizz';\n  else if (i % 5 == 0) then print 'Buzz';\n  else print i;\n  i = i + 1;\n}\n"}},967:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0});const n=["and","break","do","else","for","fn","if","of","or","print","return","then","let","while"],r=["true","false"],s=["num","str","bool"];t.default=function(e){let t=0,i="";function a(t){return t>=e.length}function o(){return e[t]}function c(){return e[t++]}function l(t){const n=e[t];return n>="a"&&n<="z"||n>="A"&&n<="Z"||"_"===n}function h(t){const n=e[t];return n>="0"&&n<="9"}function p(e){i+=e}function u(){p(c())}function E(){let e="";for(;!a(t)&&h(t);)e+=c();p(`<span class='hl_number'>${e}</span>`)}function m(){let e="";for(;!a(t)&&(l(t)||h(t));)e+=c();n.includes(e)&&(e=`<span class='hl_keyword'>${e}</span>`),s.includes(e)&&(e=`<span class='hl_type'>${e}</span>`),r.includes(e)&&(e=`<span class='hl_truefalse'>${e}</span>`),p(e)}function d(){if(a(t+1))u();else if("/"!==e[t+1])if("*"!==e[t+1])u();else{let n=c()+c(),r=1;for(;r>0&&!a(t);){if(!a(t+1)){if("/"===o()&&"*"===e[t+1]){n+=c()+c(),r++;continue}if("*"===o()&&"/"===e[t+1]){n+=c()+c(),r--;continue}}n+=c()}p(`<span class='hl_comment'>${n}</span>`)}else{let e="";for(;!a(t)&&"\n"!==o();)e+=c();p(`<span class='hl_comment'>${e}</span>`)}}function f(){const e=o();let n=c();for(;!a(t)&&o()!==e;)n+=c();a(t)||(n+=c()),p(`<span class='hl_string'>${n}</span>`)}if(0===e.length)return"";for(;!a(t);)switch(o()){case",":case".":case"-":case"+":case";":case"*":case":":case"!":case"=":case"<":case">":case" ":case"\n":case"\t":case"\r":u();break;case"(":case")":case"{":case"}":case"[":case"]":p(`<span class='hl_delimiter'>${c()}</span>`);break;case"/":d();break;case'"':case"'":f();break;default:if(h(t)){E();break}if(l(t)){m();break}u()}return i}},314:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=r(n(615)),i=r(n(885)),a=r(n(967)),o=document.getElementById("example-selection"),c=document.getElementById("run-button"),l=document.getElementById("editor"),h=document.getElementById("highlighter"),p=document.getElementById("outputBox"),u=document.getElementById("status"),E=getComputedStyle(document.body).getPropertyValue("--yellow"),m=getComputedStyle(document.body).getPropertyValue("--green"),d=getComputedStyle(document.body).getPropertyValue("--red");function f(){const e=o.value,t=i.default[e];l.innerHTML=t,x()}function x(){h.innerHTML=(0,a.default)(l.innerHTML)}function y(){const e=l.innerText,t=performance.now(),[n,r]=(0,s.default)(e),i=performance.now();p.innerHTML=n;const a=Math.round(i-t);if(r){let e;e=a>=1e3?`Failure (ran in ~${a/1e3} s)`:`Failure (ran in ~${a} ms)`,u.style.color=d,u.innerText=e}else{let e;e=a>=1e3?`Success (ran in ~${a/1e3} s)`:`Success (ran in ~${a} ms)`,u.style.color=m,u.innerText=e}}for(const e of Object.keys(i.default))o.add(new Option(e));o.addEventListener("input",f),f(),c.addEventListener("click",(()=>{u.style.color=E,u.innerText="Running...",setTimeout(y,1)})),l.spellcheck=!1,l.focus(),l.blur(),l.addEventListener("input",x),x()}},t={};!function n(r){var s=t[r];if(void 0!==s)return s.exports;var i=t[r]={exports:{}};return e[r].call(i.exports,i,i.exports,n),i.exports}(314)})();